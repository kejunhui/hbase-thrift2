/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Hbase_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace apache { namespace hadoop { namespace hbase { namespace thrift2 {

int _kTDeleteTypeValues[] = {
  TDeleteType::DELETE_COLUMN,
  TDeleteType::DELETE_COLUMNS,
  TDeleteType::DELETE_FAMILY,
  TDeleteType::DELETE_FAMILY_VERSION
};
const char* _kTDeleteTypeNames[] = {
  "DELETE_COLUMN",
  "DELETE_COLUMNS",
  "DELETE_FAMILY",
  "DELETE_FAMILY_VERSION"
};
const std::map<int, const char*> _TDeleteType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTDeleteTypeValues, _kTDeleteTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TDeleteType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDeleteType_VALUES_TO_NAMES.find(val);
  if (it != _TDeleteType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTDurabilityValues[] = {
  TDurability::SKIP_WAL,
  TDurability::ASYNC_WAL,
  TDurability::SYNC_WAL,
  TDurability::FSYNC_WAL
};
const char* _kTDurabilityNames[] = {
  "SKIP_WAL",
  "ASYNC_WAL",
  "SYNC_WAL",
  "FSYNC_WAL"
};
const std::map<int, const char*> _TDurability_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTDurabilityValues, _kTDurabilityNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TDurability::type& val) {
  std::map<int, const char*>::const_iterator it = _TDurability_VALUES_TO_NAMES.find(val);
  if (it != _TDurability_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTReadTypeValues[] = {
  TReadType::DEFAULT,
  TReadType::STREAM,
  TReadType::PREAD
};
const char* _kTReadTypeNames[] = {
  "DEFAULT",
  "STREAM",
  "PREAD"
};
const std::map<int, const char*> _TReadType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTReadTypeValues, _kTReadTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TReadType::type& val) {
  std::map<int, const char*>::const_iterator it = _TReadType_VALUES_TO_NAMES.find(val);
  if (it != _TReadType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTCompareOpValues[] = {
  TCompareOp::LESS,
  TCompareOp::LESS_OR_EQUAL,
  TCompareOp::EQUAL,
  TCompareOp::NOT_EQUAL,
  TCompareOp::GREATER_OR_EQUAL,
  TCompareOp::GREATER,
  TCompareOp::NO_OP
};
const char* _kTCompareOpNames[] = {
  "LESS",
  "LESS_OR_EQUAL",
  "EQUAL",
  "NOT_EQUAL",
  "GREATER_OR_EQUAL",
  "GREATER",
  "NO_OP"
};
const std::map<int, const char*> _TCompareOp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTCompareOpValues, _kTCompareOpNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TCompareOp::type& val) {
  std::map<int, const char*>::const_iterator it = _TCompareOp_VALUES_TO_NAMES.find(val);
  if (it != _TCompareOp_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TTimeRange::~TTimeRange() throw() {
}


void TTimeRange::__set_minStamp(const int64_t val) {
  this->minStamp = val;
}

void TTimeRange::__set_maxStamp(const int64_t val) {
  this->maxStamp = val;
}
std::ostream& operator<<(std::ostream& out, const TTimeRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTimeRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_minStamp = false;
  bool isset_maxStamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minStamp);
          isset_minStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxStamp);
          isset_maxStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_minStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTimeRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTimeRange");

  xfer += oprot->writeFieldBegin("minStamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->minStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxStamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->maxStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTimeRange &a, TTimeRange &b) {
  using ::std::swap;
  swap(a.minStamp, b.minStamp);
  swap(a.maxStamp, b.maxStamp);
}

TTimeRange::TTimeRange(const TTimeRange& other0) {
  minStamp = other0.minStamp;
  maxStamp = other0.maxStamp;
}
TTimeRange& TTimeRange::operator=(const TTimeRange& other1) {
  minStamp = other1.minStamp;
  maxStamp = other1.maxStamp;
  return *this;
}
void TTimeRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTimeRange(";
  out << "minStamp=" << to_string(minStamp);
  out << ", " << "maxStamp=" << to_string(maxStamp);
  out << ")";
}


TColumn::~TColumn() throw() {
}


void TColumn::__set_family(const std::string& val) {
  this->family = val;
}

void TColumn::__set_qualifier(const std::string& val) {
  this->qualifier = val;
__isset.qualifier = true;
}

void TColumn::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}
std::ostream& operator<<(std::ostream& out, const TColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          this->__isset.qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.qualifier) {
    xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->qualifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other2) {
  family = other2.family;
  qualifier = other2.qualifier;
  timestamp = other2.timestamp;
  __isset = other2.__isset;
}
TColumn& TColumn::operator=(const TColumn& other3) {
  family = other3.family;
  qualifier = other3.qualifier;
  timestamp = other3.timestamp;
  __isset = other3.__isset;
  return *this;
}
void TColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumn(";
  out << "family=" << to_string(family);
  out << ", " << "qualifier="; (__isset.qualifier ? (out << to_string(qualifier)) : (out << "<null>"));
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ")";
}


TColumnValue::~TColumnValue() throw() {
}


void TColumnValue::__set_family(const std::string& val) {
  this->family = val;
}

void TColumnValue::__set_qualifier(const std::string& val) {
  this->qualifier = val;
}

void TColumnValue::__set_value(const std::string& val) {
  this->value = val;
}

void TColumnValue::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TColumnValue::__set_tags(const std::string& val) {
  this->tags = val;
__isset.tags = true;
}
std::ostream& operator<<(std::ostream& out, const TColumnValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;
  bool isset_qualifier = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->tags);
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnValue");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->qualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tags) {
    xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->tags);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnValue &a, TColumnValue &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.value, b.value);
  swap(a.timestamp, b.timestamp);
  swap(a.tags, b.tags);
  swap(a.__isset, b.__isset);
}

TColumnValue::TColumnValue(const TColumnValue& other4) {
  family = other4.family;
  qualifier = other4.qualifier;
  value = other4.value;
  timestamp = other4.timestamp;
  tags = other4.tags;
  __isset = other4.__isset;
}
TColumnValue& TColumnValue::operator=(const TColumnValue& other5) {
  family = other5.family;
  qualifier = other5.qualifier;
  value = other5.value;
  timestamp = other5.timestamp;
  tags = other5.tags;
  __isset = other5.__isset;
  return *this;
}
void TColumnValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnValue(";
  out << "family=" << to_string(family);
  out << ", " << "qualifier=" << to_string(qualifier);
  out << ", " << "value=" << to_string(value);
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "tags="; (__isset.tags ? (out << to_string(tags)) : (out << "<null>"));
  out << ")";
}


TColumnIncrement::~TColumnIncrement() throw() {
}


void TColumnIncrement::__set_family(const std::string& val) {
  this->family = val;
}

void TColumnIncrement::__set_qualifier(const std::string& val) {
  this->qualifier = val;
}

void TColumnIncrement::__set_amount(const int64_t val) {
  this->amount = val;
__isset.amount = true;
}
std::ostream& operator<<(std::ostream& out, const TColumnIncrement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnIncrement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;
  bool isset_qualifier = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->amount);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnIncrement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnIncrement");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->qualifier);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.amount) {
    xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->amount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnIncrement &a, TColumnIncrement &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.amount, b.amount);
  swap(a.__isset, b.__isset);
}

TColumnIncrement::TColumnIncrement(const TColumnIncrement& other6) {
  family = other6.family;
  qualifier = other6.qualifier;
  amount = other6.amount;
  __isset = other6.__isset;
}
TColumnIncrement& TColumnIncrement::operator=(const TColumnIncrement& other7) {
  family = other7.family;
  qualifier = other7.qualifier;
  amount = other7.amount;
  __isset = other7.__isset;
  return *this;
}
void TColumnIncrement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnIncrement(";
  out << "family=" << to_string(family);
  out << ", " << "qualifier=" << to_string(qualifier);
  out << ", " << "amount="; (__isset.amount ? (out << to_string(amount)) : (out << "<null>"));
  out << ")";
}


TResult::~TResult() throw() {
}


void TResult::__set_row(const std::string& val) {
  this->row = val;
__isset.row = true;
}

void TResult::__set_columnValues(const std::vector<TColumnValue> & val) {
  this->columnValues = val;
}
std::ostream& operator<<(std::ostream& out, const TResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnValues.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->columnValues.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->columnValues[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TResult");

  if (this->__isset.row) {
    xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->row);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("columnValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnValues.size()));
    std::vector<TColumnValue> ::const_iterator _iter13;
    for (_iter13 = this->columnValues.begin(); _iter13 != this->columnValues.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TResult &a, TResult &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columnValues, b.columnValues);
  swap(a.__isset, b.__isset);
}

TResult::TResult(const TResult& other14) {
  row = other14.row;
  columnValues = other14.columnValues;
  __isset = other14.__isset;
}
TResult& TResult::operator=(const TResult& other15) {
  row = other15.row;
  columnValues = other15.columnValues;
  __isset = other15.__isset;
  return *this;
}
void TResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TResult(";
  out << "row="; (__isset.row ? (out << to_string(row)) : (out << "<null>"));
  out << ", " << "columnValues=" << to_string(columnValues);
  out << ")";
}


TAuthorization::~TAuthorization() throw() {
}


void TAuthorization::__set_labels(const std::vector<std::string> & val) {
  this->labels = val;
__isset.labels = true;
}
std::ostream& operator<<(std::ostream& out, const TAuthorization& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAuthorization::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->labels.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->labels.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readString(this->labels[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAuthorization::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAuthorization");

  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->labels.size()));
      std::vector<std::string> ::const_iterator _iter21;
      for (_iter21 = this->labels.begin(); _iter21 != this->labels.end(); ++_iter21)
      {
        xfer += oprot->writeString((*_iter21));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAuthorization &a, TAuthorization &b) {
  using ::std::swap;
  swap(a.labels, b.labels);
  swap(a.__isset, b.__isset);
}

TAuthorization::TAuthorization(const TAuthorization& other22) {
  labels = other22.labels;
  __isset = other22.__isset;
}
TAuthorization& TAuthorization::operator=(const TAuthorization& other23) {
  labels = other23.labels;
  __isset = other23.__isset;
  return *this;
}
void TAuthorization::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAuthorization(";
  out << "labels="; (__isset.labels ? (out << to_string(labels)) : (out << "<null>"));
  out << ")";
}


TCellVisibility::~TCellVisibility() throw() {
}


void TCellVisibility::__set_expression(const std::string& val) {
  this->expression = val;
__isset.expression = true;
}
std::ostream& operator<<(std::ostream& out, const TCellVisibility& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCellVisibility::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expression);
          this->__isset.expression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCellVisibility::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCellVisibility");

  if (this->__isset.expression) {
    xfer += oprot->writeFieldBegin("expression", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->expression);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCellVisibility &a, TCellVisibility &b) {
  using ::std::swap;
  swap(a.expression, b.expression);
  swap(a.__isset, b.__isset);
}

TCellVisibility::TCellVisibility(const TCellVisibility& other24) {
  expression = other24.expression;
  __isset = other24.__isset;
}
TCellVisibility& TCellVisibility::operator=(const TCellVisibility& other25) {
  expression = other25.expression;
  __isset = other25.__isset;
  return *this;
}
void TCellVisibility::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCellVisibility(";
  out << "expression="; (__isset.expression ? (out << to_string(expression)) : (out << "<null>"));
  out << ")";
}


TGet::~TGet() throw() {
}


void TGet::__set_row(const std::string& val) {
  this->row = val;
}

void TGet::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TGet::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TGet::__set_timeRange(const TTimeRange& val) {
  this->timeRange = val;
__isset.timeRange = true;
}

void TGet::__set_maxVersions(const int32_t val) {
  this->maxVersions = val;
__isset.maxVersions = true;
}

void TGet::__set_filterString(const std::string& val) {
  this->filterString = val;
__isset.filterString = true;
}

void TGet::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TGet::__set_authorizations(const TAuthorization& val) {
  this->authorizations = val;
__isset.authorizations = true;
}
std::ostream& operator<<(std::ostream& out, const TGet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->columns.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->columns[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timeRange.read(iprot);
          this->__isset.timeRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterString);
          this->__isset.filterString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _ktype32;
            ::apache::thrift::protocol::TType _vtype33;
            xfer += iprot->readMapBegin(_ktype32, _vtype33, _size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              std::string _key36;
              xfer += iprot->readBinary(_key36);
              std::string& _val37 = this->attributes[_key36];
              xfer += iprot->readBinary(_val37);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authorizations.read(iprot);
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGet");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter38;
      for (_iter38 = this->columns.begin(); _iter38 != this->columns.end(); ++_iter38)
      {
        xfer += (*_iter38).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeRange) {
    xfer += oprot->writeFieldBegin("timeRange", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->timeRange.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxVersions) {
    xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterString) {
    xfer += oprot->writeFieldBegin("filterString", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->filterString);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter39;
      for (_iter39 = this->attributes.begin(); _iter39 != this->attributes.end(); ++_iter39)
      {
        xfer += oprot->writeBinary(_iter39->first);
        xfer += oprot->writeBinary(_iter39->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->authorizations.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGet &a, TGet &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.timestamp, b.timestamp);
  swap(a.timeRange, b.timeRange);
  swap(a.maxVersions, b.maxVersions);
  swap(a.filterString, b.filterString);
  swap(a.attributes, b.attributes);
  swap(a.authorizations, b.authorizations);
  swap(a.__isset, b.__isset);
}

TGet::TGet(const TGet& other40) {
  row = other40.row;
  columns = other40.columns;
  timestamp = other40.timestamp;
  timeRange = other40.timeRange;
  maxVersions = other40.maxVersions;
  filterString = other40.filterString;
  attributes = other40.attributes;
  authorizations = other40.authorizations;
  __isset = other40.__isset;
}
TGet& TGet::operator=(const TGet& other41) {
  row = other41.row;
  columns = other41.columns;
  timestamp = other41.timestamp;
  timeRange = other41.timeRange;
  maxVersions = other41.maxVersions;
  filterString = other41.filterString;
  attributes = other41.attributes;
  authorizations = other41.authorizations;
  __isset = other41.__isset;
  return *this;
}
void TGet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGet(";
  out << "row=" << to_string(row);
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "timeRange="; (__isset.timeRange ? (out << to_string(timeRange)) : (out << "<null>"));
  out << ", " << "maxVersions="; (__isset.maxVersions ? (out << to_string(maxVersions)) : (out << "<null>"));
  out << ", " << "filterString="; (__isset.filterString ? (out << to_string(filterString)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "authorizations="; (__isset.authorizations ? (out << to_string(authorizations)) : (out << "<null>"));
  out << ")";
}


TPut::~TPut() throw() {
}


void TPut::__set_row(const std::string& val) {
  this->row = val;
}

void TPut::__set_columnValues(const std::vector<TColumnValue> & val) {
  this->columnValues = val;
}

void TPut::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TPut::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TPut::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

void TPut::__set_cellVisibility(const TCellVisibility& val) {
  this->cellVisibility = val;
__isset.cellVisibility = true;
}
std::ostream& operator<<(std::ostream& out, const TPut& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPut::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columnValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnValues.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->columnValues.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += this->columnValues[_i46].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _ktype48;
            ::apache::thrift::protocol::TType _vtype49;
            xfer += iprot->readMapBegin(_ktype48, _vtype49, _size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              std::string _key52;
              xfer += iprot->readBinary(_key52);
              std::string& _val53 = this->attributes[_key52];
              xfer += iprot->readBinary(_val53);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast54;
          xfer += iprot->readI32(ecast54);
          this->durability = (TDurability::type)ecast54;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cellVisibility.read(iprot);
          this->__isset.cellVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPut::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPut");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnValues.size()));
    std::vector<TColumnValue> ::const_iterator _iter55;
    for (_iter55 = this->columnValues.begin(); _iter55 != this->columnValues.end(); ++_iter55)
    {
      xfer += (*_iter55).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter56;
      for (_iter56 = this->attributes.begin(); _iter56 != this->attributes.end(); ++_iter56)
      {
        xfer += oprot->writeBinary(_iter56->first);
        xfer += oprot->writeBinary(_iter56->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cellVisibility) {
    xfer += oprot->writeFieldBegin("cellVisibility", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->cellVisibility.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPut &a, TPut &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columnValues, b.columnValues);
  swap(a.timestamp, b.timestamp);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.__isset, b.__isset);
}

TPut::TPut(const TPut& other57) {
  row = other57.row;
  columnValues = other57.columnValues;
  timestamp = other57.timestamp;
  attributes = other57.attributes;
  durability = other57.durability;
  cellVisibility = other57.cellVisibility;
  __isset = other57.__isset;
}
TPut& TPut::operator=(const TPut& other58) {
  row = other58.row;
  columnValues = other58.columnValues;
  timestamp = other58.timestamp;
  attributes = other58.attributes;
  durability = other58.durability;
  cellVisibility = other58.cellVisibility;
  __isset = other58.__isset;
  return *this;
}
void TPut::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPut(";
  out << "row=" << to_string(row);
  out << ", " << "columnValues=" << to_string(columnValues);
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "durability="; (__isset.durability ? (out << to_string(durability)) : (out << "<null>"));
  out << ", " << "cellVisibility="; (__isset.cellVisibility ? (out << to_string(cellVisibility)) : (out << "<null>"));
  out << ")";
}


TDelete::~TDelete() throw() {
}


void TDelete::__set_row(const std::string& val) {
  this->row = val;
}

void TDelete::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TDelete::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TDelete::__set_deleteType(const TDeleteType::type val) {
  this->deleteType = val;
__isset.deleteType = true;
}

void TDelete::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TDelete::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}
std::ostream& operator<<(std::ostream& out, const TDelete& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDelete::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->columns.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += this->columns[_i63].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast64;
          xfer += iprot->readI32(ecast64);
          this->deleteType = (TDeleteType::type)ecast64;
          this->__isset.deleteType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _ktype66;
            ::apache::thrift::protocol::TType _vtype67;
            xfer += iprot->readMapBegin(_ktype66, _vtype67, _size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              std::string _key70;
              xfer += iprot->readBinary(_key70);
              std::string& _val71 = this->attributes[_key70];
              xfer += iprot->readBinary(_val71);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast72;
          xfer += iprot->readI32(ecast72);
          this->durability = (TDurability::type)ecast72;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDelete::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDelete");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter73;
      for (_iter73 = this->columns.begin(); _iter73 != this->columns.end(); ++_iter73)
      {
        xfer += (*_iter73).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleteType) {
    xfer += oprot->writeFieldBegin("deleteType", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->deleteType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter74;
      for (_iter74 = this->attributes.begin(); _iter74 != this->attributes.end(); ++_iter74)
      {
        xfer += oprot->writeBinary(_iter74->first);
        xfer += oprot->writeBinary(_iter74->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDelete &a, TDelete &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.timestamp, b.timestamp);
  swap(a.deleteType, b.deleteType);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.__isset, b.__isset);
}

TDelete::TDelete(const TDelete& other75) {
  row = other75.row;
  columns = other75.columns;
  timestamp = other75.timestamp;
  deleteType = other75.deleteType;
  attributes = other75.attributes;
  durability = other75.durability;
  __isset = other75.__isset;
}
TDelete& TDelete::operator=(const TDelete& other76) {
  row = other76.row;
  columns = other76.columns;
  timestamp = other76.timestamp;
  deleteType = other76.deleteType;
  attributes = other76.attributes;
  durability = other76.durability;
  __isset = other76.__isset;
  return *this;
}
void TDelete::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDelete(";
  out << "row=" << to_string(row);
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "deleteType="; (__isset.deleteType ? (out << to_string(deleteType)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "durability="; (__isset.durability ? (out << to_string(durability)) : (out << "<null>"));
  out << ")";
}


TIncrement::~TIncrement() throw() {
}


void TIncrement::__set_row(const std::string& val) {
  this->row = val;
}

void TIncrement::__set_columns(const std::vector<TColumnIncrement> & val) {
  this->columns = val;
}

void TIncrement::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TIncrement::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

void TIncrement::__set_cellVisibility(const TCellVisibility& val) {
  this->cellVisibility = val;
__isset.cellVisibility = true;
}
std::ostream& operator<<(std::ostream& out, const TIncrement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TIncrement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->columns.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->columns[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _ktype83;
            ::apache::thrift::protocol::TType _vtype84;
            xfer += iprot->readMapBegin(_ktype83, _vtype84, _size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              std::string _key87;
              xfer += iprot->readBinary(_key87);
              std::string& _val88 = this->attributes[_key87];
              xfer += iprot->readBinary(_val88);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast89;
          xfer += iprot->readI32(ecast89);
          this->durability = (TDurability::type)ecast89;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cellVisibility.read(iprot);
          this->__isset.cellVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIncrement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIncrement");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnIncrement> ::const_iterator _iter90;
    for (_iter90 = this->columns.begin(); _iter90 != this->columns.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter91;
      for (_iter91 = this->attributes.begin(); _iter91 != this->attributes.end(); ++_iter91)
      {
        xfer += oprot->writeBinary(_iter91->first);
        xfer += oprot->writeBinary(_iter91->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cellVisibility) {
    xfer += oprot->writeFieldBegin("cellVisibility", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->cellVisibility.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIncrement &a, TIncrement &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.__isset, b.__isset);
}

TIncrement::TIncrement(const TIncrement& other92) {
  row = other92.row;
  columns = other92.columns;
  attributes = other92.attributes;
  durability = other92.durability;
  cellVisibility = other92.cellVisibility;
  __isset = other92.__isset;
}
TIncrement& TIncrement::operator=(const TIncrement& other93) {
  row = other93.row;
  columns = other93.columns;
  attributes = other93.attributes;
  durability = other93.durability;
  cellVisibility = other93.cellVisibility;
  __isset = other93.__isset;
  return *this;
}
void TIncrement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIncrement(";
  out << "row=" << to_string(row);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "durability="; (__isset.durability ? (out << to_string(durability)) : (out << "<null>"));
  out << ", " << "cellVisibility="; (__isset.cellVisibility ? (out << to_string(cellVisibility)) : (out << "<null>"));
  out << ")";
}


TAppend::~TAppend() throw() {
}


void TAppend::__set_row(const std::string& val) {
  this->row = val;
}

void TAppend::__set_columns(const std::vector<TColumnValue> & val) {
  this->columns = val;
}

void TAppend::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TAppend::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

void TAppend::__set_cellVisibility(const TCellVisibility& val) {
  this->cellVisibility = val;
__isset.cellVisibility = true;
}
std::ostream& operator<<(std::ostream& out, const TAppend& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAppend::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _etype97;
            xfer += iprot->readListBegin(_etype97, _size94);
            this->columns.resize(_size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              xfer += this->columns[_i98].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _ktype100;
            ::apache::thrift::protocol::TType _vtype101;
            xfer += iprot->readMapBegin(_ktype100, _vtype101, _size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              std::string _key104;
              xfer += iprot->readBinary(_key104);
              std::string& _val105 = this->attributes[_key104];
              xfer += iprot->readBinary(_val105);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast106;
          xfer += iprot->readI32(ecast106);
          this->durability = (TDurability::type)ecast106;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cellVisibility.read(iprot);
          this->__isset.cellVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAppend::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAppend");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnValue> ::const_iterator _iter107;
    for (_iter107 = this->columns.begin(); _iter107 != this->columns.end(); ++_iter107)
    {
      xfer += (*_iter107).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter108;
      for (_iter108 = this->attributes.begin(); _iter108 != this->attributes.end(); ++_iter108)
      {
        xfer += oprot->writeBinary(_iter108->first);
        xfer += oprot->writeBinary(_iter108->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cellVisibility) {
    xfer += oprot->writeFieldBegin("cellVisibility", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->cellVisibility.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAppend &a, TAppend &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.__isset, b.__isset);
}

TAppend::TAppend(const TAppend& other109) {
  row = other109.row;
  columns = other109.columns;
  attributes = other109.attributes;
  durability = other109.durability;
  cellVisibility = other109.cellVisibility;
  __isset = other109.__isset;
}
TAppend& TAppend::operator=(const TAppend& other110) {
  row = other110.row;
  columns = other110.columns;
  attributes = other110.attributes;
  durability = other110.durability;
  cellVisibility = other110.cellVisibility;
  __isset = other110.__isset;
  return *this;
}
void TAppend::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAppend(";
  out << "row=" << to_string(row);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "durability="; (__isset.durability ? (out << to_string(durability)) : (out << "<null>"));
  out << ", " << "cellVisibility="; (__isset.cellVisibility ? (out << to_string(cellVisibility)) : (out << "<null>"));
  out << ")";
}


TScan::~TScan() throw() {
}


void TScan::__set_startRow(const std::string& val) {
  this->startRow = val;
__isset.startRow = true;
}

void TScan::__set_stopRow(const std::string& val) {
  this->stopRow = val;
__isset.stopRow = true;
}

void TScan::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TScan::__set_caching(const int32_t val) {
  this->caching = val;
__isset.caching = true;
}

void TScan::__set_maxVersions(const int32_t val) {
  this->maxVersions = val;
__isset.maxVersions = true;
}

void TScan::__set_timeRange(const TTimeRange& val) {
  this->timeRange = val;
__isset.timeRange = true;
}

void TScan::__set_filterString(const std::string& val) {
  this->filterString = val;
__isset.filterString = true;
}

void TScan::__set_batchSize(const int32_t val) {
  this->batchSize = val;
__isset.batchSize = true;
}

void TScan::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TScan::__set_authorizations(const TAuthorization& val) {
  this->authorizations = val;
__isset.authorizations = true;
}

void TScan::__set_reversed(const bool val) {
  this->reversed = val;
__isset.reversed = true;
}

void TScan::__set_cacheBlocks(const bool val) {
  this->cacheBlocks = val;
__isset.cacheBlocks = true;
}

void TScan::__set_colFamTimeRangeMap(const std::map<std::string, TTimeRange> & val) {
  this->colFamTimeRangeMap = val;
__isset.colFamTimeRangeMap = true;
}

void TScan::__set_readType(const TReadType::type val) {
  this->readType = val;
__isset.readType = true;
}

void TScan::__set_limit(const int32_t val) {
  this->limit = val;
__isset.limit = true;
}
std::ostream& operator<<(std::ostream& out, const TScan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->stopRow);
          this->__isset.stopRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size111;
            ::apache::thrift::protocol::TType _etype114;
            xfer += iprot->readListBegin(_etype114, _size111);
            this->columns.resize(_size111);
            uint32_t _i115;
            for (_i115 = 0; _i115 < _size111; ++_i115)
            {
              xfer += this->columns[_i115].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->caching);
          this->__isset.caching = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timeRange.read(iprot);
          this->__isset.timeRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterString);
          this->__isset.filterString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->batchSize);
          this->__isset.batchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size116;
            ::apache::thrift::protocol::TType _ktype117;
            ::apache::thrift::protocol::TType _vtype118;
            xfer += iprot->readMapBegin(_ktype117, _vtype118, _size116);
            uint32_t _i120;
            for (_i120 = 0; _i120 < _size116; ++_i120)
            {
              std::string _key121;
              xfer += iprot->readBinary(_key121);
              std::string& _val122 = this->attributes[_key121];
              xfer += iprot->readBinary(_val122);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authorizations.read(iprot);
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reversed);
          this->__isset.reversed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cacheBlocks);
          this->__isset.cacheBlocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->colFamTimeRangeMap.clear();
            uint32_t _size123;
            ::apache::thrift::protocol::TType _ktype124;
            ::apache::thrift::protocol::TType _vtype125;
            xfer += iprot->readMapBegin(_ktype124, _vtype125, _size123);
            uint32_t _i127;
            for (_i127 = 0; _i127 < _size123; ++_i127)
            {
              std::string _key128;
              xfer += iprot->readBinary(_key128);
              TTimeRange& _val129 = this->colFamTimeRangeMap[_key128];
              xfer += _val129.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.colFamTimeRangeMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast130;
          xfer += iprot->readI32(ecast130);
          this->readType = (TReadType::type)ecast130;
          this->__isset.readType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TScan");

  if (this->__isset.startRow) {
    xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->startRow);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stopRow) {
    xfer += oprot->writeFieldBegin("stopRow", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->stopRow);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter131;
      for (_iter131 = this->columns.begin(); _iter131 != this->columns.end(); ++_iter131)
      {
        xfer += (*_iter131).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.caching) {
    xfer += oprot->writeFieldBegin("caching", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->caching);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxVersions) {
    xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeRange) {
    xfer += oprot->writeFieldBegin("timeRange", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->timeRange.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterString) {
    xfer += oprot->writeFieldBegin("filterString", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeBinary(this->filterString);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batchSize) {
    xfer += oprot->writeFieldBegin("batchSize", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->batchSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter132;
      for (_iter132 = this->attributes.begin(); _iter132 != this->attributes.end(); ++_iter132)
      {
        xfer += oprot->writeBinary(_iter132->first);
        xfer += oprot->writeBinary(_iter132->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->authorizations.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reversed) {
    xfer += oprot->writeFieldBegin("reversed", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->reversed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheBlocks) {
    xfer += oprot->writeFieldBegin("cacheBlocks", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->cacheBlocks);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.colFamTimeRangeMap) {
    xfer += oprot->writeFieldBegin("colFamTimeRangeMap", ::apache::thrift::protocol::T_MAP, 13);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colFamTimeRangeMap.size()));
      std::map<std::string, TTimeRange> ::const_iterator _iter133;
      for (_iter133 = this->colFamTimeRangeMap.begin(); _iter133 != this->colFamTimeRangeMap.end(); ++_iter133)
      {
        xfer += oprot->writeBinary(_iter133->first);
        xfer += _iter133->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.readType) {
    xfer += oprot->writeFieldBegin("readType", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32((int32_t)this->readType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScan &a, TScan &b) {
  using ::std::swap;
  swap(a.startRow, b.startRow);
  swap(a.stopRow, b.stopRow);
  swap(a.columns, b.columns);
  swap(a.caching, b.caching);
  swap(a.maxVersions, b.maxVersions);
  swap(a.timeRange, b.timeRange);
  swap(a.filterString, b.filterString);
  swap(a.batchSize, b.batchSize);
  swap(a.attributes, b.attributes);
  swap(a.authorizations, b.authorizations);
  swap(a.reversed, b.reversed);
  swap(a.cacheBlocks, b.cacheBlocks);
  swap(a.colFamTimeRangeMap, b.colFamTimeRangeMap);
  swap(a.readType, b.readType);
  swap(a.limit, b.limit);
  swap(a.__isset, b.__isset);
}

TScan::TScan(const TScan& other134) {
  startRow = other134.startRow;
  stopRow = other134.stopRow;
  columns = other134.columns;
  caching = other134.caching;
  maxVersions = other134.maxVersions;
  timeRange = other134.timeRange;
  filterString = other134.filterString;
  batchSize = other134.batchSize;
  attributes = other134.attributes;
  authorizations = other134.authorizations;
  reversed = other134.reversed;
  cacheBlocks = other134.cacheBlocks;
  colFamTimeRangeMap = other134.colFamTimeRangeMap;
  readType = other134.readType;
  limit = other134.limit;
  __isset = other134.__isset;
}
TScan& TScan::operator=(const TScan& other135) {
  startRow = other135.startRow;
  stopRow = other135.stopRow;
  columns = other135.columns;
  caching = other135.caching;
  maxVersions = other135.maxVersions;
  timeRange = other135.timeRange;
  filterString = other135.filterString;
  batchSize = other135.batchSize;
  attributes = other135.attributes;
  authorizations = other135.authorizations;
  reversed = other135.reversed;
  cacheBlocks = other135.cacheBlocks;
  colFamTimeRangeMap = other135.colFamTimeRangeMap;
  readType = other135.readType;
  limit = other135.limit;
  __isset = other135.__isset;
  return *this;
}
void TScan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScan(";
  out << "startRow="; (__isset.startRow ? (out << to_string(startRow)) : (out << "<null>"));
  out << ", " << "stopRow="; (__isset.stopRow ? (out << to_string(stopRow)) : (out << "<null>"));
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "caching="; (__isset.caching ? (out << to_string(caching)) : (out << "<null>"));
  out << ", " << "maxVersions="; (__isset.maxVersions ? (out << to_string(maxVersions)) : (out << "<null>"));
  out << ", " << "timeRange="; (__isset.timeRange ? (out << to_string(timeRange)) : (out << "<null>"));
  out << ", " << "filterString="; (__isset.filterString ? (out << to_string(filterString)) : (out << "<null>"));
  out << ", " << "batchSize="; (__isset.batchSize ? (out << to_string(batchSize)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "authorizations="; (__isset.authorizations ? (out << to_string(authorizations)) : (out << "<null>"));
  out << ", " << "reversed="; (__isset.reversed ? (out << to_string(reversed)) : (out << "<null>"));
  out << ", " << "cacheBlocks="; (__isset.cacheBlocks ? (out << to_string(cacheBlocks)) : (out << "<null>"));
  out << ", " << "colFamTimeRangeMap="; (__isset.colFamTimeRangeMap ? (out << to_string(colFamTimeRangeMap)) : (out << "<null>"));
  out << ", " << "readType="; (__isset.readType ? (out << to_string(readType)) : (out << "<null>"));
  out << ", " << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ")";
}


TMutation::~TMutation() throw() {
}


void TMutation::__set_put(const TPut& val) {
  this->put = val;
__isset.put = true;
}

void TMutation::__set_deleteSingle(const TDelete& val) {
  this->deleteSingle = val;
__isset.deleteSingle = true;
}
std::ostream& operator<<(std::ostream& out, const TMutation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMutation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->put.read(iprot);
          this->__isset.put = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deleteSingle.read(iprot);
          this->__isset.deleteSingle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMutation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMutation");

  if (this->__isset.put) {
    xfer += oprot->writeFieldBegin("put", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->put.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleteSingle) {
    xfer += oprot->writeFieldBegin("deleteSingle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->deleteSingle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMutation &a, TMutation &b) {
  using ::std::swap;
  swap(a.put, b.put);
  swap(a.deleteSingle, b.deleteSingle);
  swap(a.__isset, b.__isset);
}

TMutation::TMutation(const TMutation& other136) {
  put = other136.put;
  deleteSingle = other136.deleteSingle;
  __isset = other136.__isset;
}
TMutation& TMutation::operator=(const TMutation& other137) {
  put = other137.put;
  deleteSingle = other137.deleteSingle;
  __isset = other137.__isset;
  return *this;
}
void TMutation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMutation(";
  out << "put="; (__isset.put ? (out << to_string(put)) : (out << "<null>"));
  out << ", " << "deleteSingle="; (__isset.deleteSingle ? (out << to_string(deleteSingle)) : (out << "<null>"));
  out << ")";
}


TRowMutations::~TRowMutations() throw() {
}


void TRowMutations::__set_row(const std::string& val) {
  this->row = val;
}

void TRowMutations::__set_mutations(const std::vector<TMutation> & val) {
  this->mutations = val;
}
std::ostream& operator<<(std::ostream& out, const TRowMutations& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRowMutations::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_mutations = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mutations.clear();
            uint32_t _size138;
            ::apache::thrift::protocol::TType _etype141;
            xfer += iprot->readListBegin(_etype141, _size138);
            this->mutations.resize(_size138);
            uint32_t _i142;
            for (_i142 = 0; _i142 < _size138; ++_i142)
            {
              xfer += this->mutations[_i142].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_mutations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mutations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRowMutations::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRowMutations");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mutations.size()));
    std::vector<TMutation> ::const_iterator _iter143;
    for (_iter143 = this->mutations.begin(); _iter143 != this->mutations.end(); ++_iter143)
    {
      xfer += (*_iter143).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRowMutations &a, TRowMutations &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.mutations, b.mutations);
}

TRowMutations::TRowMutations(const TRowMutations& other144) {
  row = other144.row;
  mutations = other144.mutations;
}
TRowMutations& TRowMutations::operator=(const TRowMutations& other145) {
  row = other145.row;
  mutations = other145.mutations;
  return *this;
}
void TRowMutations::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRowMutations(";
  out << "row=" << to_string(row);
  out << ", " << "mutations=" << to_string(mutations);
  out << ")";
}


THRegionInfo::~THRegionInfo() throw() {
}


void THRegionInfo::__set_regionId(const int64_t val) {
  this->regionId = val;
}

void THRegionInfo::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void THRegionInfo::__set_startKey(const std::string& val) {
  this->startKey = val;
__isset.startKey = true;
}

void THRegionInfo::__set_endKey(const std::string& val) {
  this->endKey = val;
__isset.endKey = true;
}

void THRegionInfo::__set_offline(const bool val) {
  this->offline = val;
__isset.offline = true;
}

void THRegionInfo::__set_split(const bool val) {
  this->split = val;
__isset.split = true;
}

void THRegionInfo::__set_replicaId(const int32_t val) {
  this->replicaId = val;
__isset.replicaId = true;
}
std::ostream& operator<<(std::ostream& out, const THRegionInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t THRegionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_regionId = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->regionId);
          isset_regionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startKey);
          this->__isset.startKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endKey);
          this->__isset.endKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->offline);
          this->__isset.offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->split);
          this->__isset.split = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->replicaId);
          this->__isset.replicaId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_regionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THRegionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THRegionInfo");

  xfer += oprot->writeFieldBegin("regionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->regionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.startKey) {
    xfer += oprot->writeFieldBegin("startKey", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->startKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.endKey) {
    xfer += oprot->writeFieldBegin("endKey", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->endKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offline) {
    xfer += oprot->writeFieldBegin("offline", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.split) {
    xfer += oprot->writeFieldBegin("split", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->split);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicaId) {
    xfer += oprot->writeFieldBegin("replicaId", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->replicaId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THRegionInfo &a, THRegionInfo &b) {
  using ::std::swap;
  swap(a.regionId, b.regionId);
  swap(a.tableName, b.tableName);
  swap(a.startKey, b.startKey);
  swap(a.endKey, b.endKey);
  swap(a.offline, b.offline);
  swap(a.split, b.split);
  swap(a.replicaId, b.replicaId);
  swap(a.__isset, b.__isset);
}

THRegionInfo::THRegionInfo(const THRegionInfo& other146) {
  regionId = other146.regionId;
  tableName = other146.tableName;
  startKey = other146.startKey;
  endKey = other146.endKey;
  offline = other146.offline;
  split = other146.split;
  replicaId = other146.replicaId;
  __isset = other146.__isset;
}
THRegionInfo& THRegionInfo::operator=(const THRegionInfo& other147) {
  regionId = other147.regionId;
  tableName = other147.tableName;
  startKey = other147.startKey;
  endKey = other147.endKey;
  offline = other147.offline;
  split = other147.split;
  replicaId = other147.replicaId;
  __isset = other147.__isset;
  return *this;
}
void THRegionInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THRegionInfo(";
  out << "regionId=" << to_string(regionId);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "startKey="; (__isset.startKey ? (out << to_string(startKey)) : (out << "<null>"));
  out << ", " << "endKey="; (__isset.endKey ? (out << to_string(endKey)) : (out << "<null>"));
  out << ", " << "offline="; (__isset.offline ? (out << to_string(offline)) : (out << "<null>"));
  out << ", " << "split="; (__isset.split ? (out << to_string(split)) : (out << "<null>"));
  out << ", " << "replicaId="; (__isset.replicaId ? (out << to_string(replicaId)) : (out << "<null>"));
  out << ")";
}


TServerName::~TServerName() throw() {
}


void TServerName::__set_hostName(const std::string& val) {
  this->hostName = val;
}

void TServerName::__set_port(const int32_t val) {
  this->port = val;
__isset.port = true;
}

void TServerName::__set_startCode(const int64_t val) {
  this->startCode = val;
__isset.startCode = true;
}
std::ostream& operator<<(std::ostream& out, const TServerName& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TServerName::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hostName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostName);
          isset_hostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startCode);
          this->__isset.startCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hostName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TServerName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TServerName");

  xfer += oprot->writeFieldBegin("hostName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.startCode) {
    xfer += oprot->writeFieldBegin("startCode", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->startCode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TServerName &a, TServerName &b) {
  using ::std::swap;
  swap(a.hostName, b.hostName);
  swap(a.port, b.port);
  swap(a.startCode, b.startCode);
  swap(a.__isset, b.__isset);
}

TServerName::TServerName(const TServerName& other148) {
  hostName = other148.hostName;
  port = other148.port;
  startCode = other148.startCode;
  __isset = other148.__isset;
}
TServerName& TServerName::operator=(const TServerName& other149) {
  hostName = other149.hostName;
  port = other149.port;
  startCode = other149.startCode;
  __isset = other149.__isset;
  return *this;
}
void TServerName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TServerName(";
  out << "hostName=" << to_string(hostName);
  out << ", " << "port="; (__isset.port ? (out << to_string(port)) : (out << "<null>"));
  out << ", " << "startCode="; (__isset.startCode ? (out << to_string(startCode)) : (out << "<null>"));
  out << ")";
}


THRegionLocation::~THRegionLocation() throw() {
}


void THRegionLocation::__set_serverName(const TServerName& val) {
  this->serverName = val;
}

void THRegionLocation::__set_regionInfo(const THRegionInfo& val) {
  this->regionInfo = val;
}
std::ostream& operator<<(std::ostream& out, const THRegionLocation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t THRegionLocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_serverName = false;
  bool isset_regionInfo = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serverName.read(iprot);
          isset_serverName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->regionInfo.read(iprot);
          isset_regionInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_serverName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_regionInfo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THRegionLocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THRegionLocation");

  xfer += oprot->writeFieldBegin("serverName", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->serverName.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("regionInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->regionInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THRegionLocation &a, THRegionLocation &b) {
  using ::std::swap;
  swap(a.serverName, b.serverName);
  swap(a.regionInfo, b.regionInfo);
}

THRegionLocation::THRegionLocation(const THRegionLocation& other150) {
  serverName = other150.serverName;
  regionInfo = other150.regionInfo;
}
THRegionLocation& THRegionLocation::operator=(const THRegionLocation& other151) {
  serverName = other151.serverName;
  regionInfo = other151.regionInfo;
  return *this;
}
void THRegionLocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THRegionLocation(";
  out << "serverName=" << to_string(serverName);
  out << ", " << "regionInfo=" << to_string(regionInfo);
  out << ")";
}


TIOError::~TIOError() throw() {
}


void TIOError::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}
std::ostream& operator<<(std::ostream& out, const TIOError& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TIOError::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TIOError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIOError");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIOError &a, TIOError &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TIOError::TIOError(const TIOError& other152) : TException() {
  message = other152.message;
  __isset = other152.__isset;
}
TIOError& TIOError::operator=(const TIOError& other153) {
  message = other153.message;
  __isset = other153.__isset;
  return *this;
}
void TIOError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIOError(";
  out << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ")";
}

const char* TIOError::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TIOError";
  }
}


TIllegalArgument::~TIllegalArgument() throw() {
}


void TIllegalArgument::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}
std::ostream& operator<<(std::ostream& out, const TIllegalArgument& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TIllegalArgument::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TIllegalArgument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIllegalArgument");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIllegalArgument &a, TIllegalArgument &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TIllegalArgument::TIllegalArgument(const TIllegalArgument& other154) : TException() {
  message = other154.message;
  __isset = other154.__isset;
}
TIllegalArgument& TIllegalArgument::operator=(const TIllegalArgument& other155) {
  message = other155.message;
  __isset = other155.__isset;
  return *this;
}
void TIllegalArgument::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIllegalArgument(";
  out << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ")";
}

const char* TIllegalArgument::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TIllegalArgument";
  }
}

}}}} // namespace
